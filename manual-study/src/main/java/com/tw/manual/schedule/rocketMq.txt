RocketMQ主要组件:
    Nameserver:
        nameServer集群，topic的路由注册中心，为客户端根据Topic提供路由服务，引导
    客户端向Broker发送消息。nameServer节点之间不通信，路由信息在Nameserver集群中
    数据一致性采取的最终一致性。
        注：
            topic：消息主题，通过 Topic 对不同的业务消息进行分类。
            Tag：消息标签，用来进一步区分某个 Topic 下的消息分类，消息队列RocketMQ
            允许消费者按照 Tag 对消息进行过滤，确保消费者最终只消费到他关注的消息类
            型。
            数据一致性:一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将
            数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许
            多系统采用弱一致性来提高性能，一些不同的一致性模型也相继被提出。
            强一致性:要求无论更新操作实在哪一个副本执行,之后所有的读操作都要能获得最
            新的数据。
            弱一致性:用户读到某一操作对系统特定数据的更新需要一段时间,我们称这段时间
            为“不一致性窗口”。
            最终一致性:是弱一致性的一种特例,保证用户最终能够读取到某操作对系统特定数
            据的更新。
            数据一致性实现技术: Quorum系统NRW策略 两阶段提交算法 分布式锁服务
            (参考)https://blog.csdn.net/qq_44952664/article/details/89472160
    Broker:
        消息存储服务器,分为两种角色，Master 和 Slave，Master承担读写操作,Slave作为
    备份,当Master存在压力时,Slave可以承担读服务.所有Broker 每隔30秒会向NameServer
    发送心跳包,心跳包中会包含存在在Broker上所有的Topic的路由信息。
    Client:
        消息客户端,包括Producer和Consumer,客户端在同一时间只会连接一台nameServer,
    只有在连接出现异常时才会尝试连接另一台.客户端每隔30秒向Nameserver发起topic
    的路由信息查询.
消息订购模型:
    在RocketMq的消息消费模式采用的是发布与订阅模式。
    topic:消息主题，一类消息的集合。
    consumergroup:消息消费组，一个消费单位的群体.消费组在启动时需要订阅需要消费的
    topic。一个topic可以被多个消费组订阅,同样一个消费组也可以订阅多个主题,一个消费组
    拥有多个消费者。
        注:
            消息订购模型:
                点对点:消息生产者生产消息发送到queue中,然后消息消费者从queue中取出
                并消费消息，一个消息只会有一个消费者可以消费.
                发布订阅:消息生产者生产(发布)消息到topic,同时有多个消息消费者消费
                (订阅)该消息,发送到topic的消息会被所有订阅者订阅。
    消费模式:RocketMq支持广播模式和集群模式。
        广播模式:一个消费组内的所有消费者每个都会处理topic中的每条消息,通常用于刷新
        内存缓存。
        集群模式:一个消费组内的所有消费者共同消费一个topic中的消息,即分工协作,一个
        消费者处理一部分数据，启动负载均衡.
    负载算法(集群模式下):
        同一个消费者同一时间可以分配多个队列,但一个队列同一时间只会分配给一个消费者
        RockerMq常见平均分配算法:
            AllocateMessageQueueAveragely 平均分配
            AllocateMessageQueueAveragely 轮循分配
    重平衡机制(集群模式)
        对topic进行扩容或者对consumer进行扩容,缩容 使消息队列重新分配。
    消费进度:
        消费者消费一条消息后需要记录消费的位置,在消费端重启时,继续从上一次消费的位点
        开始进行处理新的消息。
        集群模式下消息消费进度存储在Broker端。
        广播模式下消费进度的文件存储在用户的主目录下。
    消费模型:
        RocketMq 提供了并发消费顺序消费两种消费模型。
        并发消费:
            对一个队列的消息,每个消费者内部都会创建一个线程池,对队列中的消息多线程
            处理,即偏移量大的消息比偏移量小的消息有可能先消费.
        顺序消费:
            某些场景要求消息按顺序进行消费,在RockerMq中提供了基于队列的顺序消费模型
        ,尽管一个消费组中的消费者会创建一个多线程,但针对同一个queue,会加锁.
            注:
                并发消息模型中,消息消费失败默认会重试16次.顺序消费中,如果一条消息消
            费失败,则会一直消费,直到消费成功.
事务消息
    事物消息并不是为了解决分布式事务，而是提供消息发送与业务落库的一致性，其实现原理
    就是一次分布式事务的具体应用。
定时消息
    将消费发送到broker，但消费端不会立即消费，而是到指定延迟时间才能被消费端消费。开
    源RockerMq并不支持任意精度的定时消息。
消费过滤
    根据某个特定条件对一个topic中的消息进行过滤，即只消费一个主题下满足条件的消息。